#include "utils.h"
#include <stdlib.h>
#include <stdio.h>

#include <math.h>
#include <string.h>

#ifdef LIKWID_PERFMON
#include <likwid.h>
#else
#define LIKWID_MARKER_INIT
#define LIKWID_MARKER_THREADINIT
#define LIKWID_MARKER_SWITCH
#define LIKWID_MARKER_REGISTER(regionTag)
#define LIKWID_MARKER_START(regionTag)
#define LIKWID_MARKER_STOP(regionTag)
#define LIKWID_MARKER_CLOSE
#define LIKWID_MARKER_GET(regionTag, nevents, events, time, count)
#endif

void basic_sparsemm(const COO, const COO, COO *);
void basic_sparsemm_sum(const COO, const COO, const COO,
                        const COO, const COO, const COO,
                        COO *);

void initArray(Array *a, size_t initialSize) {
  a->coords = (struct coord *)malloc(initialSize * sizeof(struct coord));
  a->data = (double *)malloc(initialSize * sizeof(double));
  a->used = 0;
  a->size = initialSize;
}

void expandArray(Array *a, int new_size) {
    a->size = new_size;
    a->data = (double *)realloc(a->data, new_size * sizeof(double));
    a->coords = (struct coord *)realloc(a->coords, new_size * sizeof(struct coord));
    printf("HAD TO REALLOC\n");
}

void freeArray(Array *a) {
  free(a->coords);
  free(a->data);
  a->used = a->size = 0;
}

int cmp_y(const void *x, const void *y){
    int (*a)[3] = (int(*)[3])x;
    int (*b)[3] = (int(*)[3])y;
    if((*a)[1]==(*b)[1])
        return (*a)[0] - (*b)[0];
    else
        return (*a)[1] - (*b)[1];
}

void convert_COO_to_CSR(const COO sparse, CSR *A_csr) {
    int *JA = malloc(sparse->NZ * sizeof(int));
    int *IA = malloc((1 + sparse->m) * sizeof(int));
    double *data = malloc(sparse->NZ * sizeof(double));

    int current_row = -1;
    int acc = 0;
    int tot = 0;
    int x, nz, rc;
    for (nz = 0; nz < sparse->NZ; nz++) {//(  (x, y) in coords) {
    	x = sparse->coords[nz].i;
        JA[nz] = sparse->coords[nz].j;
        data[nz] = sparse->data[nz];
        if (current_row != x) {//we are now on a new row. it may be greater than 1 row down.
            tot += acc;
            IA[current_row + 1] = tot;//MAY NOT BE CURRENT ROW
            acc = 0;
            if (x - current_row > 1) {// there are rows that have 0 elems on: current_row+1,...,x-1
                for (rc = current_row + 1; rc < x; rc++) {//i in range(current_row+1, x) {
                    IA[rc + 1] = tot;
                }
            }
        }
        current_row = x;
        acc ++;
    }
    IA[current_row + 1] = tot + acc;
    // alloc_csr(sparse->m, sparse->n, (1 + sparse->m), sparse->NZ, A_csr);
    // (*A_csr)->data = data;
    // (*A_csr)->IA = IA;
    // (*A_csr)->JA = JA;

    CSR sr = calloc(1, sizeof(struct _p_CSR));
    sr->m = sparse->m;
    sr->n = sparse->n;
    sr->NZ = sparse->NZ;
    sr->data = data;
    sr->IA = IA;
    sr->JA = JA;
    *A_csr = sr;
}

void convert_COO_to_CSC(const COO sparse, CSR *B_csc){//, int **coords_data) {
    CSR sr = malloc(sizeof(struct _p_CSR));
    sr->m = sparse->m;
    sr->n = sparse->n;
    sr->NZ = sparse->NZ;

    int coords_data[sparse->NZ][3];
    int idx;
    for (idx = 0; idx < sparse->NZ; idx++) {
        coords_data[idx][0] = sparse->coords[idx].i;
        coords_data[idx][1] = sparse->coords[idx].j;
        coords_data[idx][2] = idx;
    }
    qsort(coords_data, sparse->NZ, sizeof(coords_data[0]), cmp_y);

    int *JA = malloc(sparse->NZ * sizeof(int));
    int *IA = malloc((1 + sparse->n) * sizeof(int));
    double *data = malloc(sparse->NZ * sizeof(double));

    int current_col = -1;
    int acc = 0;
    int tot = 0;
    int x, y, nz, rc, data_idx;
    for (nz = 0; nz < sparse->NZ; nz++) {//(  (x, y) in coords) {
        JA[nz] = coords_data[nz][0];
        y = coords_data[nz][1];
        data_idx = coords_data[nz][2];
        data[nz] = sparse->data[data_idx];//index in data
        if (current_col != y) {//we are now on a new row. it may be greater than 1 row down.
            tot += acc;
            IA[current_col + 1] = tot;//MAY NOT BE CURRENT ROW
            acc = 0;
            if (y - current_col != 1) {// there are rows that have 0 elems on: current_col+1,...,x-1
                for (rc = current_col + 1; rc < y; rc++) {//i in range(current_col+1, x) {
                    IA[rc + 1] = tot;
                }
            }
        }
        current_col = y;
        acc ++;
    }
    IA[current_col + 1] = tot + acc;

    sr->data = data;
    sr->IA = IA;
    sr->JA = JA;

    *B_csc = sr;
}

void optimised_sparsemm(const COO A, const COO B, COO *C) {
    LIKWID_MARKER_START("optimised_profile");
	// A -> CSR
    // LIKWID_MARKER_START("A_to_CSR");
	CSR A_csr;// = calloc(1, sizeof(struct _p_CSR));
    convert_COO_to_CSR(A, &A_csr);
    // LIKWID_MARKER_STOP("A_to_CSR");
    // // B -> CSC
    // LIKWID_MARKER_START("B_to_CSB");

    CSR B_csr;
    convert_COO_to_CSC(B, &B_csr);//, coords_data);//
    // free(coords_data);
    // LIKWID_MARKER_STOP("B_to_CSB");
	//m - number of rows
	// (mA x nA) * (mB x nB )
	// nA = mB
    // LIKWID_MARKER_START("A_times_B");
    int A_m = A->m;
    int B_n = B->n;

    int improved_predict = ceil( pow((A_m * B_n * 0.0067),0.5) );//experimentally found
    
    Array a;
    int new_size;
    initArray(&a, improved_predict);

	int arow, bcol, i, j;
	float total;
	int nz = 0;


    // parallelize this loop;
    // if there are p GPUs, do:
    // split B_csr->IA into p parts (v = 0:p-1)
    // record each col in part of B (JA[IA[v]:IA[v+p]])
    // ----- send to each GPU: -----
    //      loops over section, add to its own array
    //      send back the pointer to the array and the number of elements
    // merge all arrays into one and quicksort.

    #pragma GCC ivdep
	for ( bcol = 0; bcol < B_n; bcol++ ) {//for col in B;
        //make zero vector length of column
		for (arow = 0; arow < A_m; arow++) {// for row in A:
			if (A_csr->IA[arow]!=A_csr->IA[arow+1]&&B_csr->IA[bcol]!=B_csr->IA[bcol+1]) {
                total = 0;
                i = A_csr->IA[arow], j = B_csr->IA[bcol];// i is the col index in a row of A, j is the row index of a col in B
                while (i < A_csr->IA[arow+1] && j < B_csr->IA[bcol+1]) { // m
    				if (A_csr->JA[i] < B_csr->JA[j])
    					i++;
    				else if (B_csr->JA[j] < A_csr->JA[i])
    					j++;
    				else {/* if arr1[i] == arr2[j] */
    					total += (A_csr->data[i])*(B_csr->data[j]);
    					j++;
    					i++;
    				}
    			}
    			if (total != 0) {
                    if (a.used == a.size) {
                        new_size = a.size * ceil( B_n/(bcol+1) + 0.05 );
                        printf("new size = %d ", new_size);
                        expandArray(&a, new_size);
                    }
                    a.coords[a.used].i = arow;
                    a.coords[a.used].j = bcol;
                    a.data[a.used] = total;
                    a.used++;
                    nz++; 
    			}
            }
		}
	}
    // int d, c;
    // double b_vector[B->m];
    // double a_vector[B->m];
    // for ( bcol = 0; bcol < B_n; bcol++ ) {//for col in B
    //     c=B_csr->IA[bcol];
    //     #pragma vector always
    //     for (d = 0; d < B->m; d++) {
    //         b_vector[d] = 0;
    //         if (B_csr->JA[c] == d){
    //             b_vector[d] = B_csr->data[d];
    //             c++;
    //         }
    //     }
    //     for (arow = 0; arow < A_m; arow++) {// for row in A:
    //         total = 0;
    //         c=A_csr->IA[arow];
    //         #pragma vector always
    //         for (d = 0; d < B->m; d++) {
    //             a_vector[d] = 0;
    //             if (A_csr->JA[c] == d){
    //                 a_vector[d] = A_csr->data[d];
    //                 c++;
    //             }
    //         }
    //         #pragma simd
    //         for (d = 0; d < B->m; d++) {
    //             total += a_vector[d]*b_vector[d];
    //         }
    //         if (total != 0) {
    //             if (a.used == a.size) {
    //                 new_size = a.size * ceil( B_n/(bcol+1) + 0.05 );
    //                 printf("new size = %d ", new_size);
    //                 expandArray(&a, new_size);
    //             }
    //             a.coords[a.used].i = arow;
    //             a.coords[a.used].j = bcol;
    //             a.data[a.used] = total;
    //             a.used++;
    //             nz++; 
    //         }
    //     }
    // }
    alloc_sparse(A_m, B_n, nz, C);
    (*C)->coords = a.coords;
    (*C)->data = a.data;

	free(A_csr);
	free(B_csr);
    // LIKWID_MARKER_STOP("A_times_B");
    LIKWID_MARKER_STOP("optimised_profile");
}

// void optimised_parallel(const COO A, const COO B, COO *C) {
//     //LIKWID_MARKER_START("optimised_profile");
//     // A -> CSR
//     LIKWID_MARKER_START("A_to_CSR");
//     CSR A_csr;// = calloc(1, sizeof(struct _p_CSR));
//     convert_COO_to_CSR(A, &A_csr);
//     LIKWID_MARKER_STOP("A_to_CSR");
//     // B -> CSC
//     LIKWID_MARKER_START("B_to_CSB");
//     int A_NZ = A->NZ;
//     int B_NZ = B->NZ;//put in cache
//     int coords_data[B_NZ][3];
//     int idx;
//     for (idx = 0; idx < B_NZ; idx++) {
//         coords_data[idx][0] = B->coords[idx].i;
//         coords_data[idx][1] = B->coords[idx].j;
//         coords_data[idx][2] = idx;
//     }
//     qsort(coords_data, B_NZ, sizeof(coords_data[0]), cmp_y);
//     //B is represented as coords_data = {{x_0, y_0, 0},...}

//     CSR B_csr;
//     convert_COO_to_CSC(B, &B_csr, coords_data);//
//     // free(coords_data);
//     LIKWID_MARKER_STOP("B_to_CSB");
//     //m - number of rows
//     // (mA x nA) * (mB x nB )
//     // nA = mB
//     LIKWID_MARKER_START("A_times_B");
//     int A_m = A->m;
//     int B_n = B->n;

//     int improved_predict = ceil( pow((A_m * B_n * 0.0067),0.5) );//experimentally found
    
//     Array a;
//     int new_size;
//     initArray(&a, improved_predict);

//     int arow, bcol, i, j;
//     float total;
//     int nz = 0;


//     // parallelize this loop;
//     // if there are p GPUs, do:
//     // split B_csr->IA into p parts (v = 0:p-1)
//     // record each col in part of B (JA[IA[v]:IA[v+p]])
//     // ----- send to each GPU: -----
//     //      loops over section, add to its own array
//     //      send back the pointer to the array and the number of elements
//     // merge all arrays into one and quicksort.

    
//     alloc_sparse(A_m, B_n, nz, C);
//     (*C)->coords = a.coords;
//     (*C)->data = a.data;

//     free(A_csr);
//     free(B_csr);
//     LIKWID_MARKER_STOP("A_times_B");
//     //LIKWID_MARKER_STOP("optimised_profile");
// }

// Array * execute_section(CSR * A_p, CSR * B_p, start_col, final_col) {
//     int A_m = (*A_p)->m;
//     int B_n = (*B_p)->n;

//     int improved_predict = ceil( pow((A_m * (final_col-starting_col) * 0.0067),0.5) );//experimentally found
    
//     Array a_i;
//     int new_size;
//     initArray(&a_i, improved_predict);

//     int arow, bcol, i, j;
//     float total;
//     int nz = 0;
//     for ( bcol = start_col; bcol < final_col; bcol++ ) {//for col in B;
//         for (arow = 0; arow < A_m; arow++) {// for row in A:
//             total = 0;
//             i = (*A_p)->IA[arow], j = (*B_p)->IA[bcol];// i is the col index in a row of A, j is the row index of a col in B
//             while (i < (*A_p)->IA[arow+1] && j < (*B_p)->IA[bcol+1]) { // m
//                 if ((*A_p)->JA[i] < (*B_p)->JA[j])
//                     i++;
//                 else if ((*B_p)->JA[j] < (*A_p)->JA[i])
//                     j++;
//                 else {/* if arr1[i] == arr2[j] */
//                     total += ((*A_p)->data[i])*((*B_p)->data[j]);
//                     j++;
//                     i++;
//                 }
//             }
//             if (total != 0) {
//                 if (a_i.used == a_i.size) {
//                     new_size = a_i.size * ceil( B_n/(bcol+1) + 0.05 );
//                     // printf("new size = %d ", new_size);
//                     expandArray(&a_i, new_size);
//                 }
//                 a_i.coords[a_i.used].i = arow;
//                 a_i.coords[a_i.used].j = bcol;
//                 a_i.data[a_i.used] = total;
//                 a_i.used++;
//                 nz++;
//             }
//         }
//     }
//     return (&a_i);
// }
void convert_2COO_to_1CSR(const COO sparseA, const COO sparseB, CSR *A2_csr) {
    CSR sr = malloc(sizeof(struct _p_CSR));
    sr->m = sparseA->m;
    sr->n = sparseA->n;
    int predNZ = sparseA->NZ + sparseB->NZ;

    int *JA = malloc(predNZ * sizeof(int));
    int *IA = malloc((1 + sparseA->m) * sizeof(int));
    double *data = calloc(predNZ , sizeof(double));

    int A_NZ = sparseA->NZ;
    int B_NZ = sparseB->NZ;
    // printf("A_NZ %d %d %d\n", A_NZ, B_NZ, C_NZ );
    int current_row = 0;
    // int no_options;
    int a_idx = 0, b_idx = 0;
    int acc = 0;
    int tot = 0;
    int x, rc, i, min_y, min_idx;
    int nz = 0;
    int options[2];
    while (a_idx < A_NZ || b_idx < B_NZ) {
        options[0] = 0, options[1] = 0;
        if (a_idx < A_NZ && sparseA->coords[a_idx].i == current_row) { options[0] = 1; }
        if (b_idx < B_NZ && sparseB->coords[b_idx].i == current_row) { options[1] = 1; }
        if (sparseA->coords[a_idx].i != current_row && sparseB->coords[b_idx].i != current_row) {
            //INCREMENT LEVEL!
            tot += acc;
            IA[current_row + 1] = tot;
            if (sparseA->coords[a_idx].i == current_row + 1 || sparseB->coords[b_idx].i == current_row + 1) {
                current_row++;
            } else { 
                current_row++;
                IA[current_row + 1] = 0;
                printf("\n\nmissing cols need to be added to IA\n\n\n");
            }
            acc = 0;
        } else {
                for (i = 0; i<2; i++){
                    if (options[i] == 1) {
                        if (i == 0) { options[0] = sparseA->coords[a_idx].j; }
                        if (i == 1) { options[1] = sparseB->coords[b_idx].j; }
                    } else {
                        options[i] = sparseA->n;
                    }
                }
                min_y = options[0];
                min_idx = 0;
                if (options[1] < min_y){ min_y = options[1]; min_idx = 1;}
                for (i=0;i<2;i++){
                    if (options[i] == min_y) {
                        if (i==0) { data[nz] += sparseA->data[a_idx]; a_idx++; }
                        if (i==1) { data[nz] += sparseB->data[b_idx]; b_idx++; }
                    }
                }
                JA[nz] = min_y;
                nz++;
                acc++;
        }
    }
    IA[current_row + 1] = tot + acc;
    IA[0]=0;

    // data = (double *)realloc(data, nz * sizeof(double));
    // JA = (int *)realloc(JA, nz * sizeof(int));

    sr->NZ = nz;
    sr->data = data;
    sr->IA = IA;
    sr->JA = JA;

    *A2_csr = sr;
}

void convert_3COO_to_1CSR(const COO sparseA, const COO sparseB, const COO sparseC, CSR *A2_csr) {
    CSR sr = (struct _p_CSR *)malloc(sizeof(struct _p_CSR));
    sr->m = sparseA->m;
    sr->n = sparseA->n;
    int predNZ = sparseA->NZ + sparseB->NZ + sparseC->NZ;
    // printf("NZ - A, B, C = %d, %d, %d\n", sparseA->NZ, sparseB->NZ, sparseC->NZ);
    // printf("predNZ %d\n", predNZ);
    // copy the y coords , JA
    //make IA
    int *JA = (int *)malloc(predNZ * sizeof(int));
    int *IA = (int *)malloc((1 + sparseA->m) * sizeof(int));
    double *data = (double *)calloc(predNZ , sizeof(double));

    int A_NZ = sparseA->NZ;
    int B_NZ = sparseB->NZ;
    int C_NZ = sparseC->NZ;
    // printf("A_NZ %d %d %d\n", A_NZ, B_NZ, C_NZ );
    int current_row = 0;
    // int no_options;
    int a_idx = 0, b_idx = 0, c_idx = 0;
    int acc = 0;
    int tot = 0;
    int x, rc, i, min_y, min_idx;
    // double d;
    int nz = 0;
    // for (nz = 0; nz < sparse->NZ; nz++) {//(  (x, y) in coords) {
    int options[3];
    // printf("sparseA->n %d\n", sparseA->n);
    // int v;
    // for (v=0;v<A_NZ;v++){printf("row = %d, JA[%d] = %d\n", sparseA->coords[v].i, v, sparseA->coords[v].j);}
    // printf("[a_idx].i, b, c = %d, %d, %d\n", sparseA->coords[a_idx].i, sparseB->coords[b_idx].i, sparseC->coords[c_idx].i);
    while (a_idx < A_NZ || b_idx < B_NZ || c_idx < C_NZ) {
    	// printf("idx: a = %d/%d, b = %d/%d, c = %d/%d : row: a = %d/%d,  b = %d/%d,  c = %d/%d\n", a_idx, A_NZ, b_idx, B_NZ, c_idx, C_NZ, sparseA->coords[a_idx].i, sparseA->m, sparseB->coords[b_idx].i, sparseB->m, sparseC->coords[c_idx].i, sparseC->m);
    	options[0] = 0, options[1] = 0, options[2] = 0;
    	if (a_idx < A_NZ && sparseA->coords[a_idx].i == current_row) { options[0] = 1; }
    	if (b_idx < B_NZ && sparseB->coords[b_idx].i == current_row) { options[1] = 1; }
    	if (c_idx < C_NZ && sparseC->coords[c_idx].i == current_row) { options[2] = 1; }

        // if (a_idx >= A_NZ || A_NZ == 0) { options[0] = 0; }
        // if (b_idx >= B_NZ || B_NZ == 0) { options[1] = 0; }
        // if (c_idx >= C_NZ || C_NZ == 0) { options[2] = 0; }

    	if (sparseA->coords[a_idx].i != current_row && sparseB->coords[b_idx].i != current_row && sparseC->coords[c_idx].i != current_row) {
    		//INCREMENT LEVEL!
    		printf("---------------increment row from %d, to ", current_row);
    		printf("a_idx = %d, b_idx = %d, c_idx = %d\n", a_idx, b_idx, c_idx);
    		tot += acc;
            IA[current_row + 1] = tot;
            // printf("[a_idx].i, b, c = %d, %d, %d\n", sparseA->coords[a_idx].i, sparseB->coords[b_idx].i, sparseC->coords[c_idx].i);
    		// if (current_row == sparseA->m) {break;}
            // prev_row = current_row;
            if (sparseA->coords[a_idx].i == current_row + 1 || sparseB->coords[b_idx].i == current_row + 1 || sparseC->coords[c_idx].i == current_row + 1) {
                current_row++;
            } else { 
                current_row++;
                IA[current_row + 1] = 0;
                printf("\n\nmissing cols need to be added to IA\n\n\n");
        
                // x = sparseA->coords[a_idx].i;
                // if (sparseB->coords[b_idx].i < x) { x = sparseB->coords[b_idx].i; }
                // if (sparseC->coords[c_idx].i < x) { x = sparseC->coords[c_idx].i; }
            
                // if (x - current_row > 1) {// there are rows that have 0 elems on: current_row+1,...,x-1
                //     int rc;
                //     for (rc = current_row + 1; rc < x; rc++) {//i in range(current_row+1, x) {
                //         IA[rc + 1] = tot;
                //     }
                // }
                // current_row = x;
                // printf("\n\nmissing rows need to be added to IA\n\n\n");
            }

      //       current_row = sparseA->coords[a_idx].i;
    		// if (sparseB->coords[b_idx].i < current_row) { current_row = sparseB->coords[b_idx].i; }
    		// if (sparseC->coords[c_idx].i < current_row) { current_row = sparseC->coords[c_idx].i; }
    		// printf("%d, of %d\n", current_row, sparseA->m);
    		acc = 0;
    	} else {
            // if (options[0] == 0 && options[1] == 0 && options[2] == 0) {
            //     // IA[current_row + 1] = 0;
            //     // current_row++;
            //     printf("\nfuaacccj\n\n");
            //     break;
            // } else {
                // printf("options:");
    	    	for (i = 0; i<3; i++){
                    // printf("%d,", options[i]);
    	    		if (options[i] == 1) {
    	    			if (i == 0) { options[0] = sparseA->coords[a_idx].j; }
    	    			if (i == 1) { options[1] = sparseB->coords[b_idx].j; }
    	    			if (i == 2) { options[2] = sparseC->coords[c_idx].j; }
    	    		} else {
    	    			options[i] = sparseA->n;
    	    		}
    	    	}
    	    	min_y = options[0];
    	    	min_idx = 0;
    	    	if (options[1] < min_y){ min_y = options[1]; min_idx = 1;}
    	    	if (options[2] < min_y){ min_y = options[2]; min_idx = 2;}
    	    	// increment appropriate index and place in appropriate data.
    	    	//IF MIN IS REPEATED ADD TOGETHER AND INCREMENT TOGTHER
                // printf(" > min y = %d > ", min_y);
                // printf("options:");
    	    	for (i=0;i<3;i++){
                    // printf("%d,", options[i]);
    	    		if (options[i] == min_y) {
    			    	if (i==0) { data[nz] += sparseA->data[a_idx]; a_idx++; }
    			    	if (i==1) { data[nz] += sparseB->data[b_idx]; b_idx++; }
    			    	if (i==2) { data[nz] += sparseC->data[c_idx]; c_idx++; }
    			    }
    			}
                // printf(" a_idx = %d \n",a_idx);
    		    JA[nz] = min_y;
    		    nz++;
    		    acc++;
            // }
		}
    }
    // printf("Actual NZ = %d\n", nz);
    IA[current_row + 1] = tot + acc;
    IA[0]=0;
    // printf("current_row %d\n", current_row);
    // data = (double *)realloc(data, nz * sizeof(double));
    // JA = (int *)realloc(JA, nz * sizeof(int));

    sr->NZ = nz;
    sr->data = data;
    sr->IA = IA;
    sr->JA = JA;

    *A2_csr = sr;
}

void convert_2COO_to_1CSC(const COO sparseD, const COO sparseE, CSR *B2_csr) {
    CSR sr = malloc(sizeof(struct _p_CSR));
    sr->m = sparseD->m;
    sr->n = sparseD->n;

    int predNZ = sparseD->NZ + sparseD->NZ;
    int *JA = malloc(predNZ * sizeof(int));
    int *IA = malloc((1 + sparseD->n) * sizeof(int));
    double *data = calloc(predNZ , sizeof(double));

    int idx;
    int coords_dataD[sparseD->NZ][3];
    for (idx = 0; idx < sparseD->NZ; idx++) {
        coords_dataD[idx][0] = sparseD->coords[idx].i;
        coords_dataD[idx][1] = sparseD->coords[idx].j;
        coords_dataD[idx][2] = idx;
    }
    qsort(coords_dataD, sparseD->NZ, sizeof(coords_dataD[0]), cmp_y);

    int coords_dataE[sparseE->NZ][3];
    for (idx = 0; idx < sparseE->NZ; idx++) {
        coords_dataE[idx][0] = sparseE->coords[idx].i;
        coords_dataE[idx][1] = sparseE->coords[idx].j;
        coords_dataE[idx][2] = idx;
    }
    qsort(coords_dataE, sparseE->NZ, sizeof(coords_dataE[0]), cmp_y);

    int D_NZ = sparseD->NZ;
    int E_NZ = sparseE->NZ;

    int current_col = 0;
    int d_idx = 0, e_idx = 0, f_idx = 0;
    int acc = 0;
    int tot = 0;
    int x, rc, i, min_x, min_idx;
    int nz = 0;
    int options[2];
    while (d_idx < D_NZ || e_idx < E_NZ) {
        options[0] = 0, options[1] = 0;
        if (d_idx < D_NZ && coords_dataD[d_idx][1] == current_col) { options[0] = 1; }
        if (e_idx < E_NZ && coords_dataE[e_idx][1] == current_col) { options[1] = 1; }
        if (coords_dataD[d_idx][1] != current_col && coords_dataE[e_idx][1] != current_col) {
            //INCREMENT LEVEL!
            tot += acc;
            IA[current_col + 1] = tot;
            if (coords_dataD[d_idx][1] == current_col + 1 || coords_dataE[e_idx][1] == current_col + 1) {
                current_col++;
            } else { 
                current_col++;
                IA[current_col + 1] = 0;
                printf("\n\nmissing cols need to be added to IA\n\n\n");
            }

            acc = 0;
        } else {
            for (i = 0; i<2; i++){
                if (options[i] == 1) {
                    if (i == 0) { options[0] = coords_dataD[d_idx][0]; }
                    if (i == 1) { options[1] = coords_dataE[e_idx][0]; }
                } else {
                    options[i] = sparseD->m;
                }
            }
            min_x = options[0];
            min_idx = 0;
            if (options[1] < min_x){ min_x = options[1]; min_idx = 1;}
            // increment appropriate index and place in appropriate data.
            //IF MIN IS REPEATED ADD TOGETHER AND INCREMENT TOGTHER
            for (i=0;i<2;i++){
                if (options[i] == min_x) {
                    if (i==0) { data[nz] += sparseD->data[coords_dataD[d_idx][2]]; d_idx++; }
                    if (i==1) { data[nz] += sparseE->data[coords_dataE[e_idx][2]]; e_idx++; }
                }
            }
            JA[nz] = min_x;
            nz++;
            acc++;
        }
    }
    // printf("Actual NZ = %d\n", nz);
    IA[current_col + 1] = tot + acc;
    IA[0]=0;
    // printf("current_col %d\n", current_col);
    // data = (double *)realloc(data, nz * sizeof(double));
    // JA = (int *)realloc(JA, nz * sizeof(int));

    sr->NZ = nz;
    sr->data = data;
    sr->IA = IA;
    sr->JA = JA;

    *B2_csr = sr;
}

void convert_3COO_to_1CSC(const COO sparseD, const COO sparseE, const COO sparseF, CSR *B2_csr) {
    CSR sr = (struct _p_CSR *)malloc(sizeof(struct _p_CSR));
    sr->m = sparseD->m;
    sr->n = sparseD->n;

    int predNZ = sparseD->NZ + sparseD->NZ + sparseF->NZ;

    int *JA = (int *)malloc(predNZ * sizeof(int));
    int *IA = (int *)malloc((1 + sparseD->n) * sizeof(int));
    double *data = (double *)calloc(predNZ, sizeof(double));

    int D_NZ = sparseD->NZ;
    int E_NZ = sparseE->NZ;
    int F_NZ = sparseF->NZ;


    // MAKE TRANSFORM DICTS FOR D,E,F
    int idx;
    int coords_dataD[D_NZ][3];
    for (idx = 0; idx < D_NZ; idx++) {
    	coords_dataD[idx][0] = sparseD->coords[idx].i;
    	coords_dataD[idx][1] = sparseD->coords[idx].j;
    	coords_dataD[idx][2] = idx;
    }
    qsort(coords_dataD, D_NZ, sizeof(coords_dataD[0]), cmp_y);

    int coords_dataE[E_NZ][3];
    for (idx = 0; idx < E_NZ; idx++) {
    	coords_dataE[idx][0] = sparseE->coords[idx].i;
    	coords_dataE[idx][1] = sparseE->coords[idx].j;
    	coords_dataE[idx][2] = idx;
    }
    qsort(coords_dataE, sparseE->NZ, sizeof(coords_dataE[0]), cmp_y);

    int coords_dataF[F_NZ][3];
    for (idx = 0; idx < F_NZ; idx++) {
    	coords_dataF[idx][0] = sparseF->coords[idx].i;
    	coords_dataF[idx][1] = sparseF->coords[idx].j;
    	coords_dataF[idx][2] = idx;
    }
    qsort(coords_dataF, F_NZ, sizeof(coords_dataF[0]), cmp_y);


    int current_col = 0;
    int d_idx = 0, e_idx = 0, f_idx = 0;
    int acc = 0;
    int tot = 0;
    int x, rc, i, min_x, min_idx;
    // double d;
    int nz = 0;
    // for (nz = 0; nz < sparse->NZ; nz++) {//(  (x, y) in coords) {
    int options[3];
    printf("NZ : %d %d %d\n", D_NZ, E_NZ, F_NZ);
    int v;
    // printf("[d_idx].i, b, c = %d, %d, %d\n", sparseD->coords[d_idx].i, sparseD->coords[e_idx].i, sparseF->coords[f_idx].i);
    while (d_idx < D_NZ || e_idx < E_NZ || f_idx < F_NZ) {
    	// printf("d_idx = %d, e_idx = %d, f_idx = %d\n", d_idx, e_idx, f_idx);
    	options[0] = 0, options[1] = 0, options[2] = 0;
    	if (d_idx < D_NZ && coords_dataD[d_idx][1] == current_col) { options[0] = 1; }
    	if (e_idx < E_NZ && coords_dataE[e_idx][1] == current_col) { options[1] = 1; }
    	if (f_idx < F_NZ && coords_dataF[f_idx][1] == current_col) { options[2] = 1; }
        printf("current col: %d, acc: %d, total: %d, didx=%d, eidx=%d, fidx=%d\n",current_col, acc, tot, d_idx, e_idx, f_idx);
    	if (coords_dataD[d_idx][1] != current_col && coords_dataE[e_idx][1] != current_col && coords_dataF[f_idx][1] != current_col) {
    		printf("cols: %d, %d, %d\n", coords_dataD[d_idx][1], coords_dataE[e_idx][1], coords_dataF[f_idx][1]);
            //INCREMENT LEVEL!
    		tot += acc;
            IA[current_col + 1] = tot;
            for (v=0;v<current_col;v++){printf("IA[%d] = %d\n", v, IA[v]);}
            printf("\n");
            if (coords_dataD[d_idx][1] == current_col + 1 || coords_dataE[e_idx][1] == current_col + 1 || coords_dataF[f_idx][1] == current_col + 1) {
                current_col++;
            } else { 
                current_col++;
                IA[current_col + 1] = 0;
                printf("\n\nmissing cols need to be added to IA\n\n\n");
            }
    		acc = 0;
    	} else {
            printf("options:");
            for (v=0;v<3;v++){printf("%d, ", options[v]);}
            printf("\n");
	    	for (i = 0; i<3; i++){
	    		if (options[i] == 1) {
	    			if (i == 0) { options[0] = coords_dataD[d_idx][0]; }
	    			if (i == 1) { options[1] = coords_dataE[e_idx][0]; }
	    			if (i == 2) { options[2] = coords_dataF[f_idx][0]; }
	    		} else {
	    			options[i] = sparseD->m;
	    		}
	    	}
            printf("options:");
            for (v=0;v<3;v++){printf("%d, ", options[v]);}
            printf("\n");
	    	min_x = options[0];
	    	min_idx = 0;
	    	if (options[1] < min_x){ min_x = options[1]; min_idx = 1;}
	    	if (options[2] < min_x){ min_x = options[2]; min_idx = 2; }
	    	// increment appropriate index and place in appropriate data.
	    	//IF MIN IS REPEATED ADD TOGETHER AND INCREMENT TOGTHER
	    	for (i=0;i<3;i++){
	    		if (options[i] == min_x) {
			    	if (i==0) { data[nz] += sparseD->data[coords_dataD[d_idx][2]]; d_idx++; }
			    	if (i==1) { data[nz] += sparseE->data[coords_dataE[e_idx][2]]; e_idx++; }
			    	if (i==2) { data[nz] += sparseF->data[coords_dataF[f_idx][2]]; f_idx++; }
                    printf("data:%f\n", data[nz]);
			    }
			}
            for (v=0;v<nz;v++){printf("%f, ", data[v]);}
		    JA[nz] = min_x;
		    nz++;
		    acc++;
		}
    }
    // printf("Actual NZ = %d\n", nz);
    IA[current_col + 1] = tot + acc;
    IA[0]=0;
    // printf("final_col index %d\n", current_col+1);
    // for (v=0;v<nz;v++){printf("%f, ", data[v]);}
    // data = (double *)realloc(data, nz * sizeof(double));
    // JA = (int *)realloc(JA, nz * sizeof(int));

    sr->NZ = nz;
    sr->data = data;
    sr->IA = IA;
    sr->JA = JA;

    *B2_csr = sr;
}

void optimised_sparsemm2(const CSR *A_csr, const CSR *B_csr, COO *C) {
	//m - number of rows
	// (mA x nA) * (mB x nB )
	// nA = mB
    int A_m = (*A_csr)->m;
    int B_n = (*B_csr)->n;

    int A_NZ = (*A_csr)->NZ;
    int B_NZ = (*B_csr)->NZ;

    int improved_predict = ceil( pow((A_m * B_n * 0.0067),0.5) );//experimentally found

    Array a;
    int new_size;
    initArray(&a, improved_predict);

    int arow, bcol, i, j;
    float total;
    int nz = 0;
	for ( bcol = 0; bcol < B_n; bcol++ ) {//for col in B;
		for (arow = 0; arow < A_m; arow++) {// for row in A:
			total = 0;
			i = (*A_csr)->IA[arow], j = (*B_csr)->IA[bcol];// i is the col index in a row of A, j is the row index of a col in B
			while (i < (*A_csr)->IA[arow+1] && j < (*B_csr)->IA[bcol+1]) { // m
				if ((*A_csr)->JA[i] < (*B_csr)->JA[j])
					i++;
				else if ((*B_csr)->JA[j] < (*A_csr)->JA[i])
					j++;
				else {/* if arr1[i] == arr2[j] */
					total += ((*A_csr)->data[i])*((*B_csr)->data[j]);
					j++;
					i++;
				}
			}
            if (total != 0) {
                if (a.used == a.size) {
                    new_size = a.size * ceil( B_n/(bcol+1) + 0.05 );
                    printf("new size = %d ", new_size);
                    expandArray(&a, new_size);
                }
                a.coords[a.used].i = arow;
                a.coords[a.used].j = bcol;
                a.data[a.used] = total;
                a.used++;
                nz++;
            }
		}
	}
    alloc_sparse(A_m, B_n, nz, C);
    (*C)->coords = a.coords;
    (*C)->data = a.data;

	free(*A_csr);
	free(*B_csr);
}


/* Computes O = (A + B + C) (D + E + F).
 * O should be allocated by this routine.
 */
void optimised_sparsemm_sum(const COO A, const COO B, const COO C,
                            const COO D, const COO E, const COO F,
                            COO *O)
{
 // int v;
    // LIKWID_MARKER_START("ABC_to_CSR");
    CSR A2_csr;
    if (A->NZ==0||B->NZ==0||C->NZ==0) {//if there is a zero matrix..
        //if there is only one zero matrix..
        if ((A->NZ==0&&B->NZ!=0&&C->NZ!=0) || (A->NZ!=0&&B->NZ==0&&C->NZ!=0) || (A->NZ!=0&&B->NZ!=0&&C->NZ==0)) {
            if (C->NZ==0){convert_2COO_to_1CSR(A, B, &A2_csr);}
            if (B->NZ==0){convert_2COO_to_1CSR(A, C, &A2_csr);}
            if (A->NZ==0){convert_2COO_to_1CSR(B, C, &A2_csr);}
        } else {//there are 2 or 3 zero matrices..
            if (A->NZ!=0) {convert_COO_to_CSR(A, &A2_csr);}
            if (B->NZ!=0) {convert_COO_to_CSR(B, &A2_csr);}
            if (C->NZ!=0) {convert_COO_to_CSR(C, &A2_csr);}
        }
    }else{
        convert_3COO_to_1CSR(A, B, C, &A2_csr);
    }
    // LIKWID_MARKER_STOP("ABC_to_CSR");



    // double *a_ = NULL;
    // double *b_ = NULL;
    // double *c_ = NULL;
    // int m_ = A->m;
    // int n_ = A->n;
    // convert_sparse_to_dense(A, &a_);
    // convert_sparse_to_dense(B, &b_);
    // convert_sparse_to_dense(C, &c_);
    // int i_,j_;
    // printf("A:\n");
    // for (j_ = 0; j_ < n_; j_++) {
    //     for (i_ = 0; i_ < m_; i_++) {
    //         printf("%.3f, ", a_[j_*m_ + i_]);
    //     }
    //     printf("\n");
    // }
    // printf("B:\n");
    // for (j_ = 0; j_ < n_; j_++) {
    //     for (i_ = 0; i_ < m_; i_++) {
    //         printf("%.3f, ", b_[j_*m_ + i_]);
    //     }
    //     printf("\n");
    // }
    // printf("C:\n");
    // for (j_ = 0; j_ < n_; j_++) {
    //     for (i_ = 0; i_ < m_; i_++) {
    //         printf("%.3f, ", c_[j_*m_ + i_]);
    //     }
    //     printf("\n");
    // }
    // printf("A+B+C:\n");
    // for (j_ = 0; j_ < n_; j_++) {
    //     for (i_ = 0; i_ < m_; i_++) {
    //         a_[j_*m_ + i_] += b_[j_*m_ + i_] + c_[j_*m_ + i_];
    //         printf("%.3f, ", a_[j_*m_ + i_]);
    //     }
    //     printf("\n");
    // }
    // printf("done dense\n");
    // free_dense(&b_);
    // free_dense(&c_);

    // COO t_;
    // CSR p;
    // COO* tp_ = &t_;
    // CSR* dp_ = &p;
    // // printf("a = %d\n", a);
    // convert_dense_to_sparse(a_, m_, n_, tp_);
    // // printf("NZ:%d, n:%d, m:%d\n", (*tp)->NZ, (*tp)->n, (*tp)->m);
    // // int v;
    // // for (v=0;v < (*tp)->NZ;v++) {
    // //     printf("i=%d, j=%d, sp:%f\n",(*tp)->coords[v].i,(*tp)->coords[v].j,(*tp)->data[v]);
    // // }

    // printf("done sparse\n");
    // convert_COO_to_CSR(*tp_, dp_);
    // int v;
    // printf("A2-NZ = %d\n", A2_csr->NZ);
    // int pss = 0;
    // for (v=0;v<A->m+1;v++) {if (A2_csr->IA[v]!=(*dp_)->IA[v]) {pss=1;}}
    // if (pss==1){
    //     printf("failed IA!:(((\n");
    //     for (v=0;v<A->m+1;v++) {printf("mine %d,  test:   %d\n", A2_csr->IA[v], (*dp_)->IA[v]);}
    // }else{printf("IA successfully made!\n");}
    // pss=0;
    // for (v=0;v<A2_csr->NZ;v++) {if (A2_csr->JA[v]!=(*dp_)->JA[v]) {pss=1;}}
    // if (pss==1){
    //     printf("failed JA!:(((\n");
    //     for (v=0;v<A2_csr->NZ;v++) {printf("mine %d,  test:   %d\n", A2_csr->JA[v], (*dp_)->JA[v]);}
    // }else{printf("successfully made JA!\n");}
    // pss=0;
    // for (v=0;v < A2_csr->NZ;v++) {if (A2_csr->data[v]-(*dp_)->data[v]>0.001||-A2_csr->data[v]+(*dp_)->data[v]>0.001) {pss=1;}}
    // if (pss==1){
    //     printf("failed making data!:(((\n");
    //     for (v=0;v < A2_csr->NZ;v++) {printf("mine %f,  test:   %f\n", A2_csr->data[v], (*dp_)->data[v]);}
    // }else{printf("successfully made data!\n");}
    // printf("-------%d--%d-------\n", A2_csr->NZ, (*dp_)->NZ);
    //////////////////////////////////
    // printf("\n\nchecking A:\n\n");
    
    // printf("A_csr = %p\n", A2_csr);
    // printf("FINAL : A_csr->m = %d, A_csr->n = %d, A_csr->NZ = %d\n", A2_csr->m, A2_csr->n, A2_csr->NZ);
    
    // for (v=0; v<A2_csr->m; v++){
    //  printf("IA[%d] = %d\n", v, A2_csr->IA[v]);
    // }
    // for (v=0; v<A2_csr->NZ; v++){
    //  printf("JA[%d] = %d data = %f\n", v, A2_csr->JA[v], A2_csr->data[v]);
    // }s
    printf("\n\n\n\nSTARTING B\n\n\n\n");






    // LIKWID_MARKER_START("DEF_to_CSC");
    CSR B2_csr;
    if (D->NZ==0||E->NZ==0||F->NZ==0) {//if there is a zero matrix..
        //if there is only one zero matrix..
        if ((D->NZ==0&&E->NZ!=0&&F->NZ!=0) || (D->NZ!=0&&E->NZ==0&&F->NZ!=0) || (D->NZ!=0&&E->NZ!=0&&F->NZ==0)) {
            if (F->NZ==0){convert_2COO_to_1CSC(D, E, &A2_csr);}
            if (E->NZ==0){convert_2COO_to_1CSC(D, F, &A2_csr);}
            if (D->NZ==0){convert_2COO_to_1CSC(E, F, &A2_csr);}
        } else {//there are 2 or 3 zero matrices..
            if (D->NZ!=0) {convert_COO_to_CSC(D, &A2_csr);}
            if (E->NZ!=0) {convert_COO_to_CSC(E, &A2_csr);}
            if (F->NZ!=0) {convert_COO_to_CSC(F, &A2_csr);}
        }
    }else{
        convert_3COO_to_1CSC(D, E, F, &B2_csr);
    }
    // LIKWID_MARKER_STOP("DEF_to_CSC");




    // printf("done csr\n");
    // double *a = NULL;
    // double *b = NULL;
    // double *c = NULL;
    // int m = D->m;
    // int n = D->n;
    // convert_sparse_to_dense(D, &a);
    // convert_sparse_to_dense(E, &b);
    // convert_sparse_to_dense(F, &c);
    // int i,j;
    // printf("D:\n");
    // for (j = 0; j < n; j++) {
    //     for (i = 0; i < m; i++) {
    //         printf("%.3f, ", a[j*m + i]);
    //     }
    //     printf("\n");
    // }
    // printf("E:\n");
    // for (j = 0; j < n; j++) {
    //     for (i = 0; i < m; i++) {
    //         printf("%.3f, ", b[j*m + i]);
    //     }
    //     printf("\n");
    // }
    // printf("F:\n");
    // for (j = 0; j < n; j++) {
    //     for (i = 0; i < m; i++) {
    //         printf("%.3f, ", c[j*m + i]);
    //     }
    //     printf("\n");
    // }
    // printf("D+E+F:\n");
    // for (j = 0; j < n; j++) {
    //     for (i = 0; i < m; i++) {
    //         a[j*m + i] += b[j*m + i] + c[j*m + i];
    //         printf("%.3f, ", a[j*m + i]);
    //     }
    //     printf("\n");
    // }
    // printf("done dense\n");
    // free_dense(&b);
    // free_dense(&c);

    // COO t;
    // CSR d;
    // COO* tp = &t;
    // CSR* dp = &d;
    // // printf("a = %d\n", a);
    // convert_dense_to_sparse(a, m, n, tp);
    // // printf("NZ:%d, n:%d, m:%d\n", (*tp)->NZ, (*tp)->n, (*tp)->m);
    // // int v;
    // // for (v=0;v < (*tp)->NZ;v++) {
    // //     printf("i=%d, j=%d, sp:%f\n",(*tp)->coords[v].i,(*tp)->coords[v].j,(*tp)->data[v]);
    // // }
    // printf("done sparse\n");
    // convert_COO_to_CSC(*tp, dp);

    // printf("A2-NZ = %d\n", B2_csr->NZ);
    // pss = 0;
    // for (v=0;v<D->n+1;v++) {if (B2_csr->IA[v]!=(*dp)->IA[v]) {pss=1;}}
    // if (pss==1){
    //     printf("failed IA!:(((\n");
    //     for (v=0;v<D->n+1;v++) {printf("mine %d,  test:   %d\n", B2_csr->IA[v], (*dp)->IA[v]);}
    // }else{printf("IA successfully made!\n");}
    // pss=0;
    // for (v=0;v<B2_csr->NZ;v++) {if (B2_csr->JA[v]!=(*dp)->JA[v]) {pss=1;}}
    // if (pss==1){
    //     printf("failed JA!:(((\n");
    //     for (v=0;v<B2_csr->NZ;v++) {printf("mine %d,  test:   %d\n", B2_csr->JA[v], (*dp)->JA[v]);}
    // }else{printf("successfully made JA!\n");}
    // pss=0;
    // for (v=0;v < B2_csr->NZ;v++) {if (B2_csr->data[v]-(*dp)->data[v]>0.001||-B2_csr->data[v]+(*dp)->data[v]>0.001) {pss=1;}}
    // if (pss==1){
    //     printf("failed making data!:(((\n");
    //     for (v=0;v < B2_csr->NZ;v++) {printf("mine %f,  test:   %f\n", B2_csr->data[v], (*dp)->data[v]);}
    // }else{printf("successfully made data!\n");}
    // printf("-------%d--%d-------\n", B2_csr->NZ, (*dp)->NZ);
    // printf("\n\nchecking B:\n\n");
    // printf("B2_csr = %p\n", B2_csr);
    // printf("FINAL : B2_csr->m = %d, B2_csr->n = %d, B2_csr->NZ = %d\n", B2_csr->m, B2_csr->n, B2_csr->NZ);
    // // int v;
    // for (v=0; v<B2_csr->n; v++){
    //  printf("IA[%d] = %d\n", v, B2_csr->IA[v]);
    // }
    // for (v=0; v<B2_csr->NZ; v++){
    //  printf("JA[%d] = %d data = %f\n", v, B2_csr->JA[v], B2_csr->data[v]);
    // }
    // printf("\n\nchecking\n\n");




    
    // LIKWID_MARKER_START("A_times_B");
    optimised_sparsemm2(&A2_csr, &B2_csr, O);
    // LIKWID_MARKER_STOP("A_times_B");
    printf("NZ = %d, n = %d\n", (*O)->NZ, A->n);
}

// void optimised_sparsemm_sum(const COO A, const COO B, const COO C,
//                             const COO D, const COO E, const COO F,
//                             COO *O)
// {
//     // int v;
//     // LIKWID_MARKER_START("ABC_to_CSR");
//     CSR A2_csr;
//     if (A->NZ==0||B->NZ==0||C->NZ==0) {//if there is a zero matrix..
//         //if there is only one zero matrix..
//         if ((A->NZ==0&&B->NZ!=0&&C->NZ!=0) || (A->NZ!=0&&B->NZ==0&&C->NZ!=0) || (A->NZ!=0&&B->NZ!=0&&C->NZ==0)) {
//             if (C->NZ==0){convert_2COO_to_1CSR(A, B, &A2_csr);}
//             if (B->NZ==0){convert_2COO_to_1CSR(A, C, &A2_csr);}
//             if (A->NZ==0){convert_2COO_to_1CSR(B, C, &A2_csr);}
//         } else {//there are 2 or 3 zero matrices..
//             if (A->NZ!=0) {convert_COO_to_CSR(A, &A2_csr);}
//             if (B->NZ!=0) {convert_COO_to_CSR(B, &A2_csr);}
//             if (C->NZ!=0) {convert_COO_to_CSR(C, &A2_csr);}
//         }
//     }else{
//         convert_3COO_to_1CSR(A, B, C, &A2_csr);
//     }
//     // LIKWID_MARKER_STOP("ABC_to_CSR");

//     //remake D, E, F- transposed
//     //put through COO -> CSR!!
//     int D_NZ = D->NZ;
//     int E_NZ = E->NZ;
//     int F_NZ = F->NZ;
//     int idx;
//     int coords_dataD[D_NZ][3];
//     for (idx = 0; idx < D_NZ; idx++) {
//         coords_dataD[idx][0] = D->coords[idx].i;
//         coords_dataD[idx][1] = D->coords[idx].j;
//         coords_dataD[idx][2] = idx;
//     }
//     qsort(coords_dataD, D_NZ, sizeof(coords_dataD[0]), cmp_y);

//     int coords_dataE[E_NZ][3];
//     for (idx = 0; idx < E_NZ; idx++) {
//         coords_dataE[idx][0] = E->coords[idx].i;
//         coords_dataE[idx][1] = E->coords[idx].j;
//         coords_dataE[idx][2] = idx;
//     }
//     qsort(coords_dataE, E_NZ, sizeof(coords_dataE[0]), cmp_y);

//     int coords_dataF[F_NZ][3];
//     for (idx = 0; idx < F_NZ; idx++) {
//         coords_dataF[idx][0] = F->coords[idx].i;
//         coords_dataF[idx][1] = F->coords[idx].j;
//         coords_dataF[idx][2] = idx;
//     }
//     qsort(coords_dataF, F_NZ, sizeof(coords_dataF[0]), cmp_y);

//     COO newD;
//     COO newE;
//     COO newF;
//     alloc_sparse(D->n, D->m, D->NZ, &newD);
//     alloc_sparse(E->n, E->m, E->NZ, &newE);
//     alloc_sparse(F->n, F->m, F->NZ, &newF);
//     for (idx = 0; idx < D_NZ; idx++) {
//         newD->coords[idx].i = coords_dataD[idx][1];
//         newD->coords[idx].j = coords_dataD[idx][0];
//         newD->data[idx] = D->data[coords_dataD[idx][2]];
//     }
//     // free(coords_dataD);
//     for (idx = 0; idx < E_NZ; idx++) {
//         newE->coords[idx].i = coords_dataE[idx][1];
//         newE->coords[idx].j = coords_dataE[idx][0];
//         newE->data[idx] = E->data[coords_dataE[idx][2]];
//     }
//     // free(coords_dataE);
//     for (idx = 0; idx < F_NZ; idx++) {
//         newF->coords[idx].i = coords_dataF[idx][1];
//         newF->coords[idx].j = coords_dataF[idx][0];
//         newF->data[idx] = F->data[coords_dataF[idx][2]];
//     }
//     // free(coords_dataF);
//     newD->n = D->n;
//     newE->n = E->n;
//     newF->n = F->n;
//     newD->m = D->m;
//     newE->m = E->m;
//     newF->m = F->m;

//     CSR B2_csr;
//     if (D->NZ==0||E->NZ==0||F->NZ==0) {//if there is a zero matrix..
//         //if there is only one zero matrix..
//         if ((D->NZ==0&&E->NZ!=0&&F->NZ!=0) || (D->NZ!=0&&E->NZ==0&&F->NZ!=0) || (D->NZ!=0&&E->NZ!=0&&F->NZ==0)) {
//             if (F->NZ==0){convert_2COO_to_1CSR(newD, newE, &B2_csr);}
//             if (E->NZ==0){convert_2COO_to_1CSR(newD, newF, &B2_csr);}
//             if (D->NZ==0){convert_2COO_to_1CSR(newE, newF, &B2_csr);}
//         } else {//there are 2 or 3 zero matrices..
//             if (D->NZ!=0) {convert_COO_to_CSR(newD, &B2_csr);}
//             if (E->NZ!=0) {convert_COO_to_CSR(newE, &B2_csr);}
//             if (F->NZ!=0) {convert_COO_to_CSR(newF, &B2_csr);}
//         }
//     }else{
//         convert_3COO_to_1CSR(newD, newE, newF, &B2_csr);
//     }
//     // LIKWID_MARKER_START("DEF_to_CSC");
//     // CSR B2_csr;
//     // if (D->NZ==0||E->NZ==0||F->NZ==0) {//if there is a zero matrix..
//     //     //if there is only one zero matrix..
//     //     if ((D->NZ==0&&E->NZ!=0&&F->NZ!=0) || (D->NZ!=0&&E->NZ==0&&F->NZ!=0) || (D->NZ!=0&&E->NZ!=0&&F->NZ==0)) {
//     //         if (F->NZ==0){convert_2COO_to_1CSC(D, E, &B2_csr);}
//     //         if (E->NZ==0){convert_2COO_to_1CSC(D, F, &B2_csr);}
//     //         if (D->NZ==0){convert_2COO_to_1CSC(E, F, &B2_csr);}
//     //     } else {//there are 2 or 3 zero matrices..
//     //         if (D->NZ!=0) {convert_COO_to_CSC(D, &B2_csr);}
//     //         if (E->NZ!=0) {convert_COO_to_CSC(E, &B2_csr);}
//     //         if (F->NZ!=0) {convert_COO_to_CSC(F, &B2_csr);}
//     //     }
//     // }else{
//     //     convert_3COO_to_1CSC(D, E, F, &B2_csr);
//     // }
//     // LIKWID_MARKER_STOP("DEF_to_CSC");

//     // LIKWID_MARKER_START("A_times_B");
//     optimised_sparsemm2(&A2_csr, &B2_csr, O);
//     // LIKWID_MARKER_STOP("A_times_B");
//     printf("NZ = %d, n = %d\n", (*O)->NZ, A->n);
// }










//////////////////////////////////////////////////////////////////


























// void optimised_sparsemm(const COO A, const COO B, COO *C) {
//     double *a = NULL;
//     double *b = NULL;
//     double *c = NULL;
//     LIKWID_MARKER_START("AB_to_dense");
//     convert_sparse_to_dense(A, &a);
//     convert_sparse_to_dense(B, &b);
//     LIKWID_MARKER_STOP("AB_to_dense");
//     LIKWID_MARKER_START("dense_mult");
//     dense_openAcc_matmul( A->m, A->n, B->n, &a, &b, &c );
//     LIKWID_MARKER_STOP("dense_mult");
//     LIKWID_MARKER_START("dense_to_sparse");
//     convert_dense_to_sparse(c, A->m, B->n, C);
//     LIKWID_MARKER_STOP("dense_to_sparse");
// }
// int dense_openAcc_matmul( int, int, int, float*, float*, float* );
// //A=l*m, B=m*n, pass in A, B dense as pointers, malloc C and pass address
// int dense_openAcc_matmul( int l, int m, int n, float *A, float *B, float * restrict C ) {
//    int i, j, k;   
   
//    // OpenACC data region
//    #pragma acc data copyin(A, B) copyout(C)
//    {
//       // OpenACC processing region 
//       #pragma acc kernels loop gang
//       for( i=0; i<l; i++ )            // Loop over the rows of A and C.
//       {
//         #pragma acc worker
//         for( k=0; k<n; k++ )            // Loop over the columns of B and C
//         {
//          int sum = 0;
//          #pragma acc vector reduction (+:sum)
//         // Initialize the output element for the inner
//         // product of row i of A with column j of B
//          for( j=0; j<m; j++ )            // Loop over the columns of A and C
//          {
//          sum += A[i*m+j] * B[j*n+k];   // Compute the inner product
//          }
//          C[i*n+k] = sum;
//         }
//       }
//    }
// }

